{"version":3,"sources":["components/PictureSegmentation/person2.jpg","components/PictureSegmentation/bilibili-video2.mp4","logo.svg","components/context/index.js","libs/convertSegmentationData.js","components/PictureSegmentation/PictureSegmentation.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","React","createContext","getSegmentationArea","segmentation","data","width","height","i","j","topMin","Number","MAX_SAFE_INTEGER","topMax","leftMin","leftMax","top","left","bottom","right","PictureSegmentation","imageRef","useRef","canvasRef","videoRef","videoCanvasRef","danmuContainerRef","svgRef","useEffect","a","load","architecture","outputStride","multiplier","quantBytes","catch","error","console","log","net","start","Date","getTime","segmentPerson","current","coloredPartImage","toMask","canvas","drawMask","segment","bodyCoordinate","svgData","drawPath","svg","s","XMLSerializer","serializeToString","ImgBase64","window","btoa","danmuElem","style","maskImage","WebkitMaskImage","loadModel","addEventListener","generateSegmentation","paused","ended","requestAnimationFrame","pathParam","select","attr","bindData","pathElemUpdate","selectAll","enterPath","enter","exit","remove","points","drawPathCallback","path","join","append","src","imgSrc","ref","id","className","controls","videoSrc","version","xmlns","App","useState","setUserInfo","fetchUserInfo","Promise","resolve","reject","setTimeout","userName","loggin","then","userInfo","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.ed052331.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"person2.e182c057.jpg\";","module.exports = __webpack_public_path__ + \"bilibili-video2.8097d33f.mp4\";","module.exports = __webpack_public_path__ + \"logo.25bf045c.svg\";","import React from 'react';\n\n\n\nexport const UserInfoContext = React.createContext();\n\n\n","\n\n\n/**\n * \n * @param {*} segmentation \n * @return 返回图片分割后人体区域的坐标 top, left, bottom, right\n */\nexport const getSegmentationArea = (segmentation) => {\n  if (!segmentation || !segmentation.data) {\n    return null;\n  }\n  // data应该是从上到下，从左到右输出的。\n  const {width, height, data} = segmentation;\n  let i = 0;\n  let j = 0;\n  let pos = 0;\n  let topMin = Number.MAX_SAFE_INTEGER, topMax = -1, leftMin = Number.MAX_SAFE_INTEGER, leftMax = -1;\n  for (i = 0; i < height; i++) {\n    for (j = 0; j < width; j++) {\n      pos = i* width + j;\n      const currentPosFlag = data[pos];\n      if (currentPosFlag === 1) { // foregroundIds可以设置\n        if (j <= leftMin) {\n          leftMin = j;\n        }\n        if (j > leftMax) {\n          leftMax = j;\n        }\n\n        if (i <= topMin) {\n          topMin = i;\n        }\n        if (i > topMax) {\n          topMax = i;\n        }\n      }\n    }\n  }\n  return {\n    top: topMin, \n    left: leftMin,\n    bottom: topMax,\n    right: leftMax\n  }\n}","import React, { useRef, useEffect } from 'react';\nimport { getSegmentationArea } from '../../libs/convertSegmentationData';\nimport { select } from 'd3'\n\nimport './PictureSegmentation.css';\n\nimport imgSrc from './person2.jpg';\nimport videoSrc from './bilibili-video2.mp4';\nimport { load, toMask, drawMask } from '@tensorflow-models/body-pix';\n\nexport default function PictureSegmentation() {\n\n  const imageRef = useRef(null);\n  const canvasRef = useRef(null);\n  const videoRef = useRef(null);\n  const videoCanvasRef = useRef(null);\n\n  const danmuContainerRef = useRef(null);\n\n  const svgRef = useRef(null);\n\n  useEffect(() => {\n    async function segment() {\n      const net = await load({\n        architecture: 'MobileNetV1',\n        outputStride: 16,\n        multiplier: 0.75,\n        quantBytes: 2\n      })\n      .catch(error => {\n        console.log('load engine error', error)\n      })\n      /**\n       * One of (see documentation below):\n       *   - net.segmentPerson\n       *   - net.segmentPersonParts\n       *   - net.segmentMultiPerson\n       *   - net.segmentMultiPersonParts\n       * See documentation below for details on each method.\n        */\n      const start = new Date().getTime();\n      const segmentation = await net.segmentPerson(imageRef.current)\n        .catch((error) => {\n          console.log('error', error)\n        })\n      // 处理分割花费约2秒\n      console.log(segmentation, 'cost ', new Date().getTime() - start);\n\n      const coloredPartImage = toMask(segmentation);\n      const opacity = 0.7;\n      const flipHorizontal = false;\n      const maskBlurAmount = 0;\n      const canvas = canvasRef.current;\n      // Draw the mask image on top of the original image onto a canvas.\n      // The colored part image will be drawn semi-transparent, with an opacity of\n      // 0.7, allowing for the original image to be visible under.\n      drawMask(\n        canvas, imageRef.current, coloredPartImage, opacity, maskBlurAmount,\n        flipHorizontal);\n    }\n    segment();\n\n    return () => {};\n\n  }, [imageRef])\n\n  useEffect(() => {\n        \n    let net\n\n    async function segment() {\n      /**\n       * One of (see documentation below):\n       *   - net.segmentPerson\n       *   - net.segmentPersonParts\n       *   - net.segmentMultiPerson\n       *   - net.segmentMultiPersonParts\n       * See documentation below for details on each method.\n        */\n      const segmentation = await net.segmentPerson(videoRef.current)\n        .catch((error) => {\n          console.log('error', error)\n        })\n      if (!segmentation) {\n        return;\n      }\n\n      const bodyCoordinate = getSegmentationArea(segmentation);\n\n      if (bodyCoordinate) {\n        const svgData = {\n          width: segmentation.width,\n          height: segmentation.height,\n          bodyCoordinate\n        }\n        drawPath(svgData);\n\n        const svg = svgRef.current\n        if (!svg) {\n          return;\n        }\n        const s = new XMLSerializer().serializeToString(svg);\n        const ImgBase64 = `data:image/svg+xml;base64,${window.btoa(s)}`;\n\n        const danmuElem = danmuContainerRef.current;\n        danmuElem.style.maskImage = `url(${ImgBase64})`;\n        danmuElem.style.WebkitMaskImage = `url(${ImgBase64})`;\n      }\n\n      const coloredPartImage = toMask(segmentation);\n      const opacity = 0.7;\n      const flipHorizontal = false;\n      const maskBlurAmount = 0;\n      // // Draw the mask image on top of the original image onto a canvas.\n      // // The colored part image will be drawn semi-transparent, with an opacity of\n      // // 0.7, allowing for the original image to be visible under.\n      drawMask(\n        videoCanvasRef.current, videoRef.current, coloredPartImage, opacity, maskBlurAmount,\n        flipHorizontal);\n\n    }\n    async function loadModel() {\n      net = await load({\n        architecture: 'MobileNetV1',\n        outputStride: 16,\n        multiplier: 0.5,\n        quantBytes: 2\n      })\n      .catch(error => {\n        console.log('load engine error', error)\n      })\n    }\n    \n    loadModel();\n\n    videoRef.current.addEventListener('play', () => {\n\n      async function generateSegmentation() {\n        if (!videoRef || !videoRef.current) {\n          return;\n        }\n        if(!videoRef.current.paused && !videoRef.current.ended) {\n          await segment();\n          requestAnimationFrame(generateSegmentation);\n        }\n      }\n      requestAnimationFrame(generateSegmentation);\n    });\n\n    return () => {};\n\n  }, [])\n\n  const drawPath = (pathParam) => {\n    const { width, height, bodyCoordinate } = pathParam;\n    const svg = select('#mySvg');\n    svg.attr('width', width)\n      .attr('height', height);\n    const bindData = [bodyCoordinate];\n    const pathElemUpdate = svg.selectAll('path')\n      .data(bindData);\n    const enterPath = pathElemUpdate.enter();\n    const exitPath = pathElemUpdate.exit();\n    exitPath.remove();\n\n    const startPoint = '0 0';\n    const points = [];\n    points[0] = `${width} 0`\n    points[1] = `${width} ${height}`\n    points[2] = `0 ${height}`\n\n    const drawPathCallback = function (bodyCoordinate) {\n      const {top, left, bottom, right} = bodyCoordinate;\n      points[3] = `0 ${bottom}`;\n      points[4] = `${left} ${bottom}`\n      points[5] = `${right} ${bottom}`\n      points[6] = `${right} ${top}`\n      points[7] = `${left} ${top}`\n      points[8] = points[4]\n      points[9] = points[3]\n    \n      let path = points.join(' L ');\n      path = `M${startPoint} ${path} Z`;\n      return path\n    }\n  \n    pathElemUpdate.attr('d', drawPathCallback)\n\n    enterPath\n    .append('path')\n    .attr('d', drawPathCallback)\n  }\n\n  return (\n    <>\n      <div>\n        人体分割\n      </div>\n      <img src={imgSrc} ref={imageRef}></img>\n      <canvas id=\"canvas\" ref={canvasRef}></canvas>\n\n      <div className=\"videoContainer\">\n        <video controls src={videoSrc} id=\"myVideo\" ref={videoRef}> </video>\n\n        <div className=\"danmuContainer\" ref={danmuContainerRef}>\n          <div className=\"danmuContent\">this is a danmu this is a danmu this is a danmu this is a danmu this is a danmu </div>\n          <div className=\"danmuContent\">this is a danmu this is a danmu this is a danmu this is a danmu this is a danmu</div>\n          <div className=\"danmuContent\">this is a danmu this is a danmu this is a danmu this is a danmu this is a danmu</div>\n          <div className=\"danmuContent\">this is a danmu this is a danmu this is a danmu this is a danmu this is a danmu</div>\n          <div className=\"danmuContent\">this is a danmu this is a danmu this is a danmu this is a danmu this is a danmu</div>\n          <div className=\"danmuContent\">this is a danmu this is a danmu this is a danmu this is a danmu this is a danmu</div>\n          <div className=\"danmuContent\">this is a danmu this is a danmu this is a danmu this is a danmu this is a danmu</div>\n          <div className=\"danmuContent\">this is a danmu this is a danmu this is a danmu this is a danmu this is a danmu</div>\n          <div className=\"danmuContent\">this is a danmu this is a danmu this is a danmu this is a danmu this is a danmu</div>\n          <div className=\"danmuContent\">this is a danmu this is a danmu this is a danmu this is a danmu this is a danmu</div>\n          <div className=\"danmuContent\">this is a danmu this is a danmu this is a danmu this is a danmu this is a danmu</div>\n          <div className=\"danmuContent\">this is a danmu this is a danmu this is a danmu this is a danmu this is a danmu</div>\n          <div className=\"danmuContent\">this is a danmu this is a danmu this is a danmu this is a danmu this is a danmu</div>\n          <div className=\"danmuContent\">this is a danmu this is a danmu this is a danmu this is a danmu this is a danmu</div>\n          <div className=\"danmuContent\">this is a danmu this is a danmu this is a danmu this is a danmu this is a danmu</div>\n        </div>\n      </div>\n      <canvas id=\"videoCanvas\" ref={videoCanvasRef}></canvas>\n\n      <svg width=\"0\" height=\"0\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" id=\"mySvg\" ref={svgRef}>\n      </svg>\n    </>\n  );\n}\n","import React, {useEffect, useState} from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport {BrowserRouter, Link, Route} from 'react-router-dom';\nimport {UserInfoContext} from './components/context';\nimport VideoPlayer from './components/VideoPlayer/VideoPlayer'\nimport PictureSegmentation from './components/PictureSegmentation/PictureSegmentation'\n\n\nfunction App() {\n    const [userInfo, setUserInfo] = useState({});\n\n    // 这个fetch函数可以用useMero保存起来，或者从外部导入\n    function fetchUserInfo() {\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                resolve({\n                    userName: 'Tom',\n                    loggin: true\n                });\n            }, 1000);\n        });\n    }\n\n    useEffect(() => {\n        fetchUserInfo().then(userInfo => {\n            setUserInfo(userInfo);\n        });\n    }, []);\n\n    const onLoginChange = () => {\n        if (userInfo.loggin) {\n            setUserInfo({});\n            return;\n        }\n        fetchUserInfo().then(userInfo => {\n            setUserInfo(userInfo);\n        });\n    };\n\n  return (\n    <PictureSegmentation />\n  )\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}